{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ConsoleDot service in Go This projects aims to cover all basic concepts needed for development of service for console.redhat.com.","title":"Home"},{"location":"#consoledot-service-in-go","text":"This projects aims to cover all basic concepts needed for development of service for console.redhat.com.","title":"ConsoleDot service in Go"},{"location":"concepts/01-documentation/","text":"Documentation for your project This is a bit meta you say, sure it is! :) We believe starting with documentation is important, so you don't need to catch up later. Architecture Start with simple architecture of your project. You've sure brainstormed it before starting, just put in the docs folder what you have! Diagrams can be plain png s of course, but if you want to start with something better, do it with PlantUML. It helps you keep it up to date, because you keep the source code of the diagram with the code. Architecture Decision Records These Markdown documents are meant to document major decisions you've taken during your project development. Changing decisions is easy with a follow-up ADR, but you get an awesome benefit of the track record for the decisions. That's very helpful for every new developer, like you after few months working on something else ;) See more for example at adr.GitHub.io","title":"Documentation"},{"location":"concepts/01-documentation/#documentation-for-your-project","text":"This is a bit meta you say, sure it is! :) We believe starting with documentation is important, so you don't need to catch up later.","title":"Documentation for your project"},{"location":"concepts/01-documentation/#architecture","text":"Start with simple architecture of your project. You've sure brainstormed it before starting, just put in the docs folder what you have! Diagrams can be plain png s of course, but if you want to start with something better, do it with PlantUML. It helps you keep it up to date, because you keep the source code of the diagram with the code.","title":"Architecture"},{"location":"concepts/01-documentation/#architecture-decision-records","text":"These Markdown documents are meant to document major decisions you've taken during your project development. Changing decisions is easy with a follow-up ADR, but you get an awesome benefit of the track record for the decisions. That's very helpful for every new developer, like you after few months working on something else ;) See more for example at adr.GitHub.io","title":"Architecture Decision Records"},{"location":"concepts/02-makefile/","text":"Makefile Golan has a tooling around many commands. We believe it is helpful to customize these commands for actual project needs. We help document all the current targets by providing the make help we encourage you to continue this effort. It makes it very easy for new developers to see what common actions are needed for working on the project. We drafted the Makefile targets split under mk directory, so it's easier to keep targets grouped by their purpose.","title":"Makefile"},{"location":"concepts/02-makefile/#makefile","text":"Golan has a tooling around many commands. We believe it is helpful to customize these commands for actual project needs. We help document all the current targets by providing the make help we encourage you to continue this effort. It makes it very easy for new developers to see what common actions are needed for working on the project. We drafted the Makefile targets split under mk directory, so it's easier to keep targets grouped by their purpose.","title":"Makefile"},{"location":"concepts/03-building/","text":"Building your project Exciting! We are getting somewhere :) You can run your app by: make run And you can build a container for it locally by: make build-podman Following information is all about what happens when you run these commands :) Go dependencies We have three make targets for working with dependencies: make download-deps installs dependencies locally (aliased make prep ) make update-deps updates dependencies to the newest versions make tidy-deps cleans up dependencies locally The binary The main binary is called api and it serves as api application http server for our service. It's entry point is cmd/api/main.go Containerization Your app will run in the production environment in Container in OpenShift. So lets package our app in a Container :) You can build the container with Podman by running make build-podman . There are two phases in the build. It is captured in Containerfile . First is the build phase. We use the official Red Hat go-toolset build container to build our projects. We have manually set the go version of the container, when bumping the go version, it needs to be bumped here. The build itself is done by copying all project files in /build directory in the build container. Followed by running make prep build strip which runs phases: Install dependencies Building binaries Stripping binaries of debug information (to keep them smaller). FROM registry.access.redhat.com/ubi8/go-toolset:1:18 as build USER 0 RUN mkdir /build WORKDIR /build COPY . . RUN make prep build strip Second phase produces the final container image It just copies the binaries from the build container. FROM registry.access.redhat.com/ubi8/ubi-minimal:latest COPY --from=build /build/api /api USER 1001 CMD [\"/api\"] We are done :)","title":"Building"},{"location":"concepts/03-building/#building-your-project","text":"Exciting! We are getting somewhere :) You can run your app by: make run And you can build a container for it locally by: make build-podman Following information is all about what happens when you run these commands :)","title":"Building your project"},{"location":"concepts/03-building/#go-dependencies","text":"We have three make targets for working with dependencies: make download-deps installs dependencies locally (aliased make prep ) make update-deps updates dependencies to the newest versions make tidy-deps cleans up dependencies locally","title":"Go dependencies"},{"location":"concepts/03-building/#the-binary","text":"The main binary is called api and it serves as api application http server for our service. It's entry point is cmd/api/main.go","title":"The binary"},{"location":"concepts/03-building/#containerization","text":"Your app will run in the production environment in Container in OpenShift. So lets package our app in a Container :) You can build the container with Podman by running make build-podman . There are two phases in the build. It is captured in Containerfile .","title":"Containerization"},{"location":"concepts/03-building/#first-is-the-build-phase","text":"We use the official Red Hat go-toolset build container to build our projects. We have manually set the go version of the container, when bumping the go version, it needs to be bumped here. The build itself is done by copying all project files in /build directory in the build container. Followed by running make prep build strip which runs phases: Install dependencies Building binaries Stripping binaries of debug information (to keep them smaller). FROM registry.access.redhat.com/ubi8/go-toolset:1:18 as build USER 0 RUN mkdir /build WORKDIR /build COPY . . RUN make prep build strip","title":"First is the build phase."},{"location":"concepts/03-building/#second-phase-produces-the-final-container-image","text":"It just copies the binaries from the build container. FROM registry.access.redhat.com/ubi8/ubi-minimal:latest COPY --from=build /build/api /api USER 1001 CMD [\"/api\"] We are done :)","title":"Second phase produces the final container image"}]}